import{P as O,V as x,T as Z,B as R,e as k,f as C,c as F,G as U,s as T,g as X,a as j,r as B,h as D,R as L,i as Y}from"./3d_objects-14t7cS8V.js";class b{static roundNumber(e,n){const t=Math.pow(10,n);return Math.round(e*t)/t}static sample(e){return e[Math.floor(Math.random()*e.length)]}static distanceToSquared(e,n){var t=e.x-n.x,s=e.y-n.y,o=e.z-n.z;return t*t+s*s+o*o}static isPointInPoly(e,n){for(var t=!1,s=-1,o=e.length,r=o-1;++s<o;r=s)(e[s].z<=n.z&&n.z<e[r].z||e[r].z<=n.z&&n.z<e[s].z)&&n.x<(e[r].x-e[s].x)*(n.z-e[s].z)/(e[r].z-e[s].z)+e[s].x&&(t=!t);return t}static isVectorInPolygon(e,n,t){var s=1e5,o=-1e5,r=[];return n.vertexIds.forEach(h=>{s=Math.min(t[h].y,s),o=Math.max(t[h].y,o),r.push(t[h])}),!!(e.y<o+.5&&e.y>s-.5&&this.isPointInPoly(r,e))}static triarea2(e,n,t){return(t.x-e.x)*(n.z-e.z)-(n.x-e.x)*(t.z-e.z)}static vequal(e,n){return this.distanceToSquared(e,n)<1e-5}static mergeVertices(e,n=1e-4){n=Math.max(n,Number.EPSILON);for(var t={},s=e.getIndex(),o=e.getAttribute("position"),r=s?s.count:o.count,h=0,i=[],c=[],v=Math.log10(1/n),f=Math.pow(10,v),g=0;g<r;g++){var a=s?s.getX(g):g,p="";p+=~~(o.getX(a)*f)+",",p+=~~(o.getY(a)*f)+",",(p+=~~(o.getZ(a)*f)+",")in t?i.push(t[p]):(c.push(o.getX(a)),c.push(o.getY(a)),c.push(o.getZ(a)),t[p]=h,i.push(h),h++)}const u=new R(new Float32Array(c),o.itemSize,o.normalized),l=new k;return l.setAttribute("position",u),l.setIndex(i),l}}class ${constructor(e){this.content=[],this.scoreFunction=e}push(e){this.content.push(e),this.sinkDown(this.content.length-1)}pop(){const e=this.content[0],n=this.content.pop();return this.content.length>0&&(this.content[0]=n,this.bubbleUp(0)),e}remove(e){const n=this.content.indexOf(e),t=this.content.pop();n!==this.content.length-1&&(this.content[n]=t,this.scoreFunction(t)<this.scoreFunction(e)?this.sinkDown(n):this.bubbleUp(n))}size(){return this.content.length}rescoreElement(e){this.sinkDown(this.content.indexOf(e))}sinkDown(e){const n=this.content[e];for(;e>0;){const t=(e+1>>1)-1,s=this.content[t];if(!(this.scoreFunction(n)<this.scoreFunction(s)))break;this.content[t]=n,this.content[e]=s,e=t}}bubbleUp(e){const n=this.content.length,t=this.content[e],s=this.scoreFunction(t);for(;;){const o=e+1<<1,r=o-1;let h,i=null;if(r<n&&(h=this.scoreFunction(this.content[r]),h<s&&(i=r)),o<n&&this.scoreFunction(this.content[o])<(i===null?s:h)&&(i=o),i===null)break;this.content[e]=this.content[i],this.content[i]=t,e=i}}}class H{constructor(){this.portals=[]}push(e,n){n===void 0&&(n=e),this.portals.push({left:e,right:n})}stringPull(){const e=this.portals,n=[];let t,s,o,r=0,h=0,i=0;t=e[0].left,s=e[0].left,o=e[0].right,n.push(t);for(let c=1;c<e.length;c++){const v=e[c].left,f=e[c].right;if(b.triarea2(t,o,f)<=0){if(!(b.vequal(t,o)||b.triarea2(t,s,f)>0)){n.push(s),t=s,r=h,s=t,o=t,h=r,i=r,c=r;continue}o=f,i=c}if(b.triarea2(t,s,v)>=0){if(!(b.vequal(t,s)||b.triarea2(t,o,v)<0)){n.push(o),t=o,r=i,s=t,o=t,h=r,i=r,c=r;continue}s=v,h=c}}return n.length!==0&&b.vequal(n[n.length-1],e[e.length-1].left)||n.push(e[e.length-1].left),this.path=n,n}}class E{constructor(){this.zones={}}static createZone(e,n=1e-4){return(class{static buildZone(t,s){const o=this._buildNavigationMesh(t,s),r={};o.vertices.forEach(i=>{i.x=b.roundNumber(i.x,2),i.y=b.roundNumber(i.y,2),i.z=b.roundNumber(i.z,2)}),r.vertices=o.vertices;const h=this._buildPolygonGroups(o);return r.groups=new Array(h.length),h.forEach((i,c)=>{const v=new Map;i.forEach((g,a)=>{v.set(g,a)});const f=new Array(i.length);i.forEach((g,a)=>{const p=[];g.neighbours.forEach(y=>p.push(v.get(y)));const u=[];g.neighbours.forEach(y=>u.push(this._getSharedVerticesInOrder(g,y)));const l=new x(0,0,0);l.add(r.vertices[g.vertexIds[0]]),l.add(r.vertices[g.vertexIds[1]]),l.add(r.vertices[g.vertexIds[2]]),l.divideScalar(3),l.x=b.roundNumber(l.x,2),l.y=b.roundNumber(l.y,2),l.z=b.roundNumber(l.z,2),f[a]={id:a,neighbours:p,vertexIds:g.vertexIds,centroid:l,portals:u}}),r.groups[c]=f}),r}static _buildNavigationMesh(t,s){return t=b.mergeVertices(t,s),this._buildPolygonsFromGeometry(t)}static _spreadGroupId(t){let s=new Set([t]);for(;s.size>0;){const o=s;s=new Set,o.forEach(r=>{r.group=t.group,r.neighbours.forEach(h=>{h.group===void 0&&s.add(h)})})}}static _buildPolygonGroups(t){const s=[];return t.polygons.forEach(o=>{o.group!==void 0?s[o.group].push(o):(o.group=s.length,this._spreadGroupId(o),s.push([o]))}),s}static _buildPolygonNeighbours(t,s){const o=new Set,r=s[t.vertexIds[1]],h=s[t.vertexIds[2]];return s[t.vertexIds[0]].forEach(i=>{i!==t&&(r.includes(i)||h.includes(i))&&o.add(i)}),r.forEach(i=>{i!==t&&h.includes(i)&&o.add(i)}),o}static _buildPolygonsFromGeometry(t){const s=[],o=[],r=t.attributes.position,h=t.index,i=[];for(let c=0;c<r.count;c++)o.push(new x().fromBufferAttribute(r,c)),i[c]=[];for(let c=0;c<t.index.count;c+=3){const v=h.getX(c),f=h.getX(c+1),g=h.getX(c+2),a={vertexIds:[v,f,g],neighbours:null};s.push(a),i[v].push(a),i[f].push(a),i[g].push(a)}return s.forEach(c=>{c.neighbours=this._buildPolygonNeighbours(c,i)}),{polygons:s,vertices:o}}static _getSharedVerticesInOrder(t,s){const o=t.vertexIds,r=o[0],h=o[1],i=o[2],c=s.vertexIds,v=c.includes(r),f=c.includes(h),g=c.includes(i);return v&&f&&g?Array.from(o):v&&f?[r,h]:f&&g?[h,i]:v&&g?[i,r]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}).buildZone(e,n)}setZoneData(e,n){this.zones[e]=n}getRandomNode(e,n,t,s){if(!this.zones[e])return new x;t=t||null,s=s||0;const o=[];return this.zones[e].groups[n].forEach(r=>{t&&s?b.distanceToSquared(t,r.centroid)<s*s&&o.push(r.centroid):o.push(r.centroid)}),b.sample(o)||new x}getClosestNode(e,n,t,s=!1){const o=this.zones[n].vertices;let r=null,h=1/0;return this.zones[n].groups[t].forEach(i=>{const c=b.distanceToSquared(i.centroid,e);c<h&&(!s||b.isVectorInPolygon(e,i,o))&&(r=i,h=c)}),r}findPath(e,n,t,s){const o=this.zones[t].groups[s],r=this.zones[t].vertices,h=this.getClosestNode(e,t,s,!0),i=this.getClosestNode(n,t,s,!0);if(!h||!i)return null;const c=(class{static init(a){for(let p=0;p<a.length;p++){const u=a[p];u.f=0,u.g=0,u.h=0,u.cost=1,u.visited=!1,u.closed=!1,u.parent=null}}static cleanUp(a){for(let p=0;p<a.length;p++){const u=a[p];delete u.f,delete u.g,delete u.h,delete u.cost,delete u.visited,delete u.closed,delete u.parent}}static heap(){return new $(function(a){return a.f})}static search(a,p,u){this.init(a);const l=this.heap();for(l.push(p);l.size()>0;){const y=l.pop();if(y===u){let w=y;const z=[];for(;w.parent;)z.push(w),w=w.parent;return this.cleanUp(z),z.reverse()}y.closed=!0;const P=this.neighbours(a,y);for(let w=0,z=P.length;w<z;w++){const m=P[w];if(m.closed)continue;const _=y.g+m.cost,G=m.visited;if(!G||_<m.g){if(m.visited=!0,m.parent=y,!m.centroid||!u.centroid)throw new Error("Unexpected state");m.h=m.h||this.heuristic(m.centroid,u.centroid),m.g=_,m.f=m.g+m.h,G?l.rescoreElement(m):l.push(m)}}}return[]}static heuristic(a,p){return b.distanceToSquared(a,p)}static neighbours(a,p){const u=[];for(let l=0;l<p.neighbours.length;l++)u.push(a[p.neighbours[l]]);return u}}).search(o,h,i),v=function(a,p){for(var u=0;u<a.neighbours.length;u++)if(a.neighbours[u]===p.id)return a.portals[u]},f=new H;f.push(e);for(let a=0;a<c.length;a++){const p=c[a],u=c[a+1];if(u){const l=v(p,u);f.push(r[l[0]],r[l[1]])}}f.push(n),f.stringPull();const g=f.path.map(a=>new x(a.x,a.y,a.z));return g.shift(),g}}E.prototype.getGroup=(function(){const d=new O;return function(e,n,t=!1){if(!this.zones[e])return null;let s=null,o=Math.pow(50,2);const r=this.zones[e];for(let h=0;h<r.groups.length;h++){const i=r.groups[h];for(const c of i){if(t&&(d.setFromCoplanarPoints(r.vertices[c.vertexIds[0]],r.vertices[c.vertexIds[1]],r.vertices[c.vertexIds[2]]),Math.abs(d.distanceToPoint(n))<.01)&&b.isPointInPoly([r.vertices[c.vertexIds[0]],r.vertices[c.vertexIds[1]],r.vertices[c.vertexIds[2]]],n))return h;const v=b.distanceToSquared(c.centroid,n);v<o&&(s=h,o=v)}}return s}})(),E.prototype.clampStep=(function(){const d=new x,e=new O,n=new Z,t=new x;let s,o,r=new x;return function(h,i,c,v,f,g){const a=this.zones[v].vertices,p=this.zones[v].groups[f],u=[c],l={};l[c.id]=0,s=void 0,r.set(0,0,0),o=1/0,e.setFromCoplanarPoints(a[c.vertexIds[0]],a[c.vertexIds[1]],a[c.vertexIds[2]]),e.projectPoint(i,d),t.copy(d);for(let y=u.pop();y;y=u.pop()){n.set(a[y.vertexIds[0]],a[y.vertexIds[1]],a[y.vertexIds[2]]),n.closestPointToPoint(t,d),d.distanceToSquared(t)<o&&(s=y,r.copy(d),o=d.distanceToSquared(t));const P=l[y.id];if(!(P>2))for(let w=0;w<y.neighbours.length;w++){const z=p[y.neighbours[w]];z.id in l||(u.push(z),l[z.id]=P+1)}}return g.copy(r),s}})();const M=new E,A="level1";let I;const q=[],S=new C,W=new X,N=.02;F.position.set(0,2.2,0);function J(){K(()=>{Q()}),V(),window.addEventListener("pointerdown",se)}function K(d){new U().load("./pista.glb",n=>{const t=n.scene;T.add(t),I=t.children.find(s=>s.isMesh),I&&(I.visible=!0,M.setZoneData(A,E.createZone(I.geometry)),console.log("Malla de navegación cargada y lista."),d&&d())},void 0,n=>{console.error("Error al cargar pista.glb:",n)})}function Q(){if(!I)return;const e=new L(new x(0,5,0),new x(0,-1,0)).intersectObject(I,!1);if(e.length>0){const n=e[0].point;ee(n.x,n.y+N,n.z),console.log(`Agente creado en posición inicial segura: Y=${n.y+N}`)}else console.error("ERROR: El raycaster no pudo encontrar la malla en (0,0,0).")}function ee(d,e,n){const t=Y(d,e,n,N);T.add(t),t.path=[],t.speed=1,q.push(t)}function te(d){q.forEach(e=>{if(e.path&&e.path.length>0){const n=e.path[0].clone();n.y+=N;const t=n.clone().sub(e.position);t.lengthSq()>e.speed*d*e.speed*d?(t.normalize(),e.position.add(t.multiplyScalar(e.speed*d))):(e.position.copy(n),e.path.shift())}})}function ne(d,e){const n=M.getGroup(A,e.position);if(!I||n===null){console.warn("Malla no cargada o agente/destino fuera de la malla de navegación.");return}const t=M.findPath(e.position,d,A,n);t&&t.length?(e.path=t,console.log(`Ruta calculada con ${t.length} puntos.`)):(e.path=[],console.warn("No se pudo encontrar una ruta al destino."))}function se(d){S.x=d.clientX/window.innerWidth*2-1,S.y=-(d.clientY/window.innerHeight)*2+1,D.setFromCamera(S,F);const e=D.intersectObject(I,!1);if(e.length>0){const n=e[0].point,t=q[0];ne(n,t)}}function V(){requestAnimationFrame(V);const d=W.getDelta();j.update(),te(d),B.render(T,F)}J();
